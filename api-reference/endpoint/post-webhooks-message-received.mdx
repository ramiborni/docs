---
title: "Message Received Webhook"
description: "Webhook payload invoked when a LinkedIn message arrives"
tags:
  - webhooks
  - messaging
---

SendPilot delivers inbound LinkedIn messages via webhooks in real-time. This webhook is triggered when a LinkedIn message is received in response to a sent message.

## Event Type

`MESSAGE_RECEIVED` (or `message.received`)

**Triggered when:** A LinkedIn message is received in response to a sent message (30 seconds to 5 minutes delay in sandbox)

## Webhook Event Payload

<ParamField body="eventId" type="string" required>
  Unique identifier for this webhook event. Use for idempotency tracking.
  
  Example: `evt_msg_received_1699358400000`
</ParamField>

<ParamField body="eventType" type="string" required>
  Type of message event. Value: `message.received`
</ParamField>

<ParamField body="timestamp" type="string" required>
  ISO-8601 timestamp when SendPilot captured the event.
  
  Example: `2025-11-07T10:00:00.000Z`
</ParamField>

<ParamField body="data" type="object" required>
  Event data containing message details.
  
  <Expandable title="Data object">
    <ParamField body="accountId" type="string" required>
      LinkedIn account ID that received the message.
      
      Example: `clxxx123456`
    </ParamField>
    
    <ParamField body="conversationId" type="string" required>
      Unique conversation thread identifier.
      
      Example: `conv_abc123def456`
    </ParamField>
    
    <ParamField body="messageId" type="string" required>
      Unique message identifier for the received message.
      
      Example: `msg_reply_1699358400000`
    </ParamField>
    
    <ParamField body="originalMessageId" type="string" required>
      ID of the original message that this is a reply to.
      
      Example: `msg_abc123`
    </ParamField>
    
    <ParamField body="senderProfileUrl" type="string" required>
      LinkedIn profile URL of the sender.
      
      Example: `https://www.linkedin.com/in/john-doe`
    </ParamField>
    
    <ParamField body="recipientProfileUrl" type="string" required>
      Profile URL of the recipient (your LinkedIn account).
      
      Example: `clxxx123456`
    </ParamField>
    
    <ParamField body="textContent" type="string" required>
      Message text content.
      
      Example: `Thanks for reaching out! I'd be happy to connect.`
    </ParamField>
    
    <ParamField body="direction" type="string" required>
      Message direction. Value: `INBOUND`
    </ParamField>
    
    <ParamField body="receivedAt" type="string" required>
      ISO-8601 timestamp when the message was received.
      
      Example: `2025-11-07T10:00:00.000Z`
    </ParamField>
  </Expandable>
</ParamField>

## Example Webhook Payload

```json
{
  "eventId": "evt_msg_received_1699358400000",
  "eventType": "message.received",
  "timestamp": "2025-11-07T10:00:00.000Z",
  "data": {
    "accountId": "clxxx123456",
    "conversationId": "conv_abc123def456",
    "messageId": "msg_reply_1699358400000",
    "originalMessageId": "msg_abc123",
    "senderProfileUrl": "https://www.linkedin.com/in/john-doe",
    "recipientProfileUrl": "clxxx123456",
    "textContent": "Thanks for reaching out! I'd be happy to connect.",
    "direction": "INBOUND",
    "receivedAt": "2025-11-07T10:00:00.000Z"
  }
}
```

## Expected Response

Your webhook endpoint should respond with:

```json
{
  "received": true
}
```

**HTTP Status:** `200 OK`

## Implementation Guidance

### Basic Handler

```javascript
// Express.js example
app.post('/webhooks/message-received', async (req, res) => {
  const signature = req.headers['x-sendpilot-signature'];
  
  // 1. Verify webhook signature
  if (!verifyWebhookSignature(req.body, signature, WEBHOOK_SECRET)) {
    return res.status(401).json({ error: 'Invalid signature' });
  }
  
  const event = req.body;
  
  // 2. Check for duplicate events (idempotency)
  const isDuplicate = await checkEventProcessed(event.eventId);
  if (isDuplicate) {
    return res.status(200).json({ received: true });
  }
  
  // 3. Process the message
  try {
    await processInboundMessage(event);
    
    // 4. Mark event as processed
    await markEventProcessed(event.eventId);
    
    // 5. Respond with 200 to acknowledge receipt
    res.status(200).json({ received: true });
  } catch (error) {
    console.error('Error processing webhook:', error);
    // Return 500 to trigger SendPilot retry
    res.status(500).json({ error: 'Processing failed' });
  }
});
```

### Signature Verification

Verify the webhook signature to ensure requests are from SendPilot:

```javascript
const crypto = require('crypto');

function verifyWebhookSignature(payload, signature, secret) {
  const parts = signature.split(',');
  const timestamp = parts[0].split('=')[1];
  const signatureHash = parts[1].split('=')[1];
  
  // Prevent replay attacks - reject old timestamps
  const age = Date.now() / 1000 - parseInt(timestamp);
  if (age > 300) { // 5 minutes
    return false;
  }
  
  const signedPayload = `${timestamp}.${JSON.stringify(payload)}`;
  const expectedHash = crypto
    .createHmac('sha256', secret)
    .update(signedPayload)
    .digest('hex');
  
  return crypto.timingSafeEqual(
    Buffer.from(expectedHash),
    Buffer.from(signatureHash)
  );
}
```

### Idempotency Handling

Prevent duplicate processing using the `eventId`:

```javascript
const processedEvents = new Set(); // In production, use Redis or database

async function checkEventProcessed(eventId) {
  return processedEvents.has(eventId);
}

async function markEventProcessed(eventId) {
  processedEvents.add(eventId);
  
  // In production: Store in database with TTL
  await redis.setex(`webhook:${eventId}`, 86400, 'processed');
}
```

### Message Processing

Process the inbound message and trigger your AI response:

```javascript
async function processInboundMessage(event) {
  const { eventId, eventType, data, timestamp } = event;
  
  // 1. Store message in database
  await db.messages.create({
    eventId,
    messageId: data.messageId,
    conversationId: data.conversationId,
    accountId: data.accountId,
    senderProfileUrl: data.senderProfileUrl,
    textContent: data.textContent,
    eventType,
    receivedAt: new Date(timestamp)
  });
  
  // 2. Generate AI response
  const context = await getConversationContext(data.conversationId);
  const aiResponse = await generateResponse(data.textContent, context);
  
  // 3. Send response via SendPilot
  const axios = require('axios');
  const url = 'https://integration-api-gateway.agreeablesea-e4815929.swedencentral.azurecontainerapps.io/api/linkedin/messaging/message';
  
  await axios.post(url, {
    linkedinAccountId: data.accountId,
    leadUrl: data.senderProfileUrl,
    text: aiResponse
  }, {
    headers: {
      'X-API-KEY': "YOUR_API_KEY",
      'Content-Type': 'application/json'
    }
  });
}
```

## Retry Behavior

SendPilot implements automatic retries for failed webhook deliveries:

- **Retry on**: 5xx errors, network timeouts
- **No retry on**: 2xx, 4xx responses
- **Retry schedule**: Exponential backoff (1s, 5s, 30s, 5m, 30m)
- **Max attempts**: 5

<Warning>
Always respond with `200 OK` once you've successfully received and queued the webhook for processing. Respond with `5xx` only if you want SendPilot to retry.
</Warning>

## Response Codes

| Status | Meaning | SendPilot Action |
|--------|---------|------------------|
| 200 | Success - event processed | No retry |
| 400 | Invalid payload | No retry, log error |
| 401 | Signature validation failed | No retry, alert SendPilot team |
| 500 | Temporary failure | Retry with exponential backoff |

## Best Practices

<Tip>
Process webhooks asynchronously. Acknowledge receipt immediately (return 200) and queue the actual processing.
</Tip>

### Async Processing Pattern

```javascript
const queue = require('bull'); // Or any queue system
const messageQueue = new queue('message-processing');

app.post('/webhooks/message-received', async (req, res) => {
  // Verify signature
  if (!verifyWebhookSignature(req.body, req.headers['x-sendpilot-signature'], WEBHOOK_SECRET)) {
    return res.status(401).json({ error: 'Invalid signature' });
  }
  
  // Immediately acknowledge and queue for processing
  await messageQueue.add(req.body);
  res.status(200).json({ received: true });
});

// Process asynchronously
messageQueue.process(async (job) => {
  const event = job.data;
  await processInboundMessage(event);
});
```

## Security Considerations

1. **Always verify signatures**: Never process unverified webhook requests
2. **Implement replay protection**: Check timestamp age in signatures
3. **Use HTTPS**: Webhook endpoints must use TLS/SSL
4. **Rate limiting**: Protect against malicious flood attacks
5. **IP whitelisting**: Restrict to SendPilot's IP ranges if possible

## Common Issues

| Issue | Cause | Solution |
|-------|-------|----------|
| Signature validation fails | Incorrect secret or payload parsing | Verify webhook secret, ensure payload is raw JSON |
| Duplicate events | SendPilot retries after timeout | Implement idempotency using `eventId` |
| Timeouts | Slow synchronous processing | Move processing to async queue |
| Missing webhooks | Endpoint downtime or 5xx errors | Monitor uptime, implement fallback polling |
